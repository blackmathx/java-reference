Generics
===================

// Without Generics. Supports legacy code
List list1 = new ArrayList();  // must now downcast when retrieving
list1.add("str");
String s = (String) list1.get(0);

// With Generics
List<String> list2 = new ArrayList<>();
list2.add("string");
String s = list2.get(0);


// A method taking lists holding any type
public static void doPrint(List<?> l){
	for(Object o : l)
		System.out.println(o);
}


// Create a List that can accept any type
List<Object> l = new ArrayList<>();

// Another way to pass lists of any type (upperBound): GenericType<? extends OtherType>
public static void doSth(List<? extends Number> l){   // takes Integer, Double,...
	...
}


// Another way to pass lists of any type (lowerBound)
public static void doSthElse(List<? super Integer> l){  /// any super class of Integer
	...
}


// Generic Methods
public static <T> void print(T[] t){ // adds type parameter before the return value
	...
}
// Constrain the Type parameters example
public static <E extends Comparable> E min(E[] arr){   // extends is same as implements when used in type parameters
	...
}



// Writing Generic Types
public class Point<T> {
	T x, y;
	public Point(T x, T y){	this.x = x; this.y = y;	}

	public T getX(){ return x; }
	...
}
Point<Integer> in = new Point<>();
Point<Double> do = new Point<>();